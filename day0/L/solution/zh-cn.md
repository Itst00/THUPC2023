{{ self.title() }}

作者，版权声明等

## 题目简述

给定序列 $a_1,\dots,a_n$ ，共 $m$ 次操作；

每次操作给出 $x,l,r$ ，首先按顺序将 $a_1,\dots,a_n$ 与 $x$ 比较，若 $x>a_i$ 则交换 $a_i,x$ 的值，处理完这些比较和交换操作后查询 $\sum\limits_{i=l}^r a_i$ 。

## 算法

维护取得非严格前缀最小值的位置，记为第一层；

维护取得去掉第一层的位置后，取得非严格前缀最小值的位置，记为第二层；

每层的位置从左到右对应的值非严格单调递减。

对第二层的每个位置，维护左边严格小于它的值的个数，记为序列 $t$；

每次操作可能导致第二层的位置变为第一层的位置，第二层新增位置，但已经在第一层的位置不会离开；

每次操作如果发生了交换，则导致第一层的位置从第一次交换的位置开始的后缀上的值整体向后移动一步，第一次交换的位置变为 $x$ ；第二层的值不超过 $x$ 的位置后缀对应序列 $t$ 减一，当 $t$ 减少到0时第二层的位置变为第一层的位置，第二层可能新增一些位置，需要计算 $t$。

为了处理这些操作需要维护：

第一层在序列区间上的位置个数，单点修改

第一层在值域区间上的位置个数，单点修改，查kth

第一层在值域区间上的和，单点修改

除了第一层外的位置在序列区间上的和，单点修改

除了第一层外的位置在序列区间上的最小值，单点修改，查给定位置向右第一个不超过给定值的位置

$t$ 序列，区间加，查最左的0的位置和存在性

可以用线段树维护，时间复杂度 $O((n+m)\log n)$。